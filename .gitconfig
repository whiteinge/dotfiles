[user]
    email = seth@eseth.com
    name = Seth House

[alias]
    st = status -s -b
    ci = commit
    co = checkout
    d = diff
    dc = diff --cached
    b = branch -vv
    bc = branch --contains
    f = fetch --all
    r = rebase
    re = reset --hard @{upstream}
    short = rev-parse --short
    m = merge --no-ff
    up = merge --ff-only @{upstream}
    cdate = show --format="%ci"

    # Perform a merge in-memory and output if any conflicts are found (dry-run)
    # Takes the name of a branch / ref to merge
    mergetest = "!sh -c 'git merge-tree `git merge-base $1 HEAD` $1 HEAD \
        | awk '\\''/^@@/ { print \"Conflicts found\"; exit 1 }'\\''' -"

    l = log --oneline --decorate
    ll = log --stat --decorate --abbrev-commit --date=relative
    lll = log -p --stat --decorate --abbrev-commit --date=relative
    llll = "!sh -c 'git lll $@ \
        | gvim - -R -v -c \"set ft=git\" -c \"set fdm=syntax\"' -"

    rl = reflog --date=relative
    stat = diff --stat

    # http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html
    ctags = !.git/hooks/ctags

    serve = "!git daemon --base-path=$(git rev-parse --show-toplevel) --export-all"

    # Open all modified files in EDITOR
    editm = "!$EDITOR $(git ls-files -m)"

    # Alias to make an archive with a prefix set to the name of the repo
    tar = "!git archive --prefix=$(basename $(git rev-parse --show-toplevel))/"

    # Show all remote branches that have been merged
    allmerged = "!git branch -r -v --no-abbrev --merged | \
        awk '!/master*|develop*|HEAD/ { print $2,$1 }'"

    # Show the correct SHA for merging from FETCH_HEADS
    showfetchhead = "!awk '!/not-for-merge/ {print $1}' \
        $(git rev-parse --git-dir)/FETCH_HEAD"

    # Compare local branches to remote branches (without doing a fetch!)
    # Takes (optional) remote name as an argument; default: "upstream".
    # FIXME: branches that are ahead of upstream will also be shown.
    showstale = "!bash -c 'join -j 2 \
        <(git show-ref --heads) \
        <(git ls-remote --heads ${1:-upstream}) \
        | awk '\\''{ if ($2 != $3) print $1 }'\\''' -"

    ### Custom Git commands (found in ~/bin)
    # Push only the current branch to the upstream branch
    p = pushcurrent

    # Show individual diffs for all incoming/outgoing changesets
    in = pagediffs ..@{u}
    out = pagediffs @{u}..

    # Output the commit that git svn dcommit will attempt to commit on top of
    svnhead = !git --no-pager log --grep=^git-svn-id: --first-parent -1

    # Output URL to make a GitHub pull request
    # git preq remotename branchname
    preq = "!sh -c 'git remote show -n $1 | \
        awk -F: '\\''/Push'\\\\'s+URL/ { sub(/'\\\\'.git/, x, $3); \
        print \"https://github.com/\"$3\"/pull/new/\"br }'\\'' br=$2' -"

    # Output git command to pull a remote branch from a pull request
    # git mpreq remotename ghuser:branch
    mpreq = "!sh -c 'git remote show -n $1 | \
        awk -F/ '\\''/Push'\\\\'s+URL/ { \
        sub(/'\\\\'.git/, x, $2); split(fk, f, \":\"); \
        print \"git pull https://github.com/\"f[1]\"/\"$2, f[2] }'\\'' fk=$2' -"

    # Configure local clone to also make local refs for all GitHub pull
    # requests for the specified remote
    # Usage: git addrefspr upstream; git fetch upstream; git show upstream/pr/13
    addrefspr = "!sh -c 'git config --add \
        remote.$1.fetch \"+refs/pull/*/head:refs/remotes/$1/pr/*\"' -"

[core]
    excludesfile = ~/.gitignore

[color]
    ui = auto

[init]
    templatedir = ~/.git_template

[sendemail]
    smtpencryption = tls
    smtpserver = smtp.gmail.com
    smtpuser = whiteinge@gmail.com
    smtpserverport = 587

[diff]
    tool = clivimdiff

[difftool "clivimdiff"]
    cmd = gvimdiff -v $LOCAL $REMOTE

[merge]
    tool = diffconflicts

[mergetool "diffconflicts"]
    cmd = diffconflicts $EDITOR $BASE $LOCAL $REMOTE $MERGED
    trustExitCode = true
    keepBackup = false

[mergetool "gdiffconflicts"]
    cmd = diffconflicts gvim $BASE $LOCAL $REMOTE $MERGED
    trustExitCode = true
    keepBackup = false
